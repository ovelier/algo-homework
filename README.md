# 实验室安排系统

## 项目概述

本项目是为《算法与数据结构设计》课程开发的实验室安排系统,用于自动化管理实验室资源分配和课程调度。系统采用C++结合Qt框架开发,使用SQLite作为数据库,实现了实验室信息管理、实验课申请管理、智能课表生成和课表查询等核心功能。

### 开发环境
- **编程语言**: C++
- **UI框架**: Qt 6.9.2
- **数据库**: SQLite 3
- **构建工具**: CMake
- **编译器**: MSVC 2022

---

## 核心功能

### 1. 实验室信息录入功能
- 录入实验室地址(例如:实验楼A301)
- 录入实验室容纳学生数量
- 支持实验室信息的增删查改

### 2. 实验课申请录入功能
- 录入班级ID、班级人数、指导教师
- 设置申请优先级(数字越小优先级越高)
- 可视化时间段选择:
  - **蓝色标记**: 期望的实验安排时间段(√)
  - **红色标记**: 不期望的实验安排时间段(×)
- 时间范围: 第9周和第10周,每周周一至周五,每天上午/下午两个时段

### 3. 课表生成功能
- 基于**优先级贪心算法**自动生成课程安排
- 将生成的课表写入SQLite数据库
- 提供详细的调度统计信息(成功率、失败列表等)

### 4. 课表查询功能
- **按实验室查询**: 查看特定实验室的所有课程安排
- **按班级查询**: 查看特定班级的所有实验安排
- 以表格形式展示完整的课程信息

---

## 算法设计(重点)

### 算法核心思想

本系统采用**基于优先级的贪心调度算法**,结合**多阶段匹配策略**,在满足约束条件下最大化资源利用率。

### 算法设计理念

1. **公平性原则**: 按照申请时间顺序(优先级)进行分配,先申请者优先满足
2. **最优匹配**: 优先满足教师期望的时间段,提高满意度
3. **资源约束**: 严格检查实验室容量,确保安全
4. **冲突避免**: 防止同一实验室同一时间段重复分配

### 算法详细流程

#### 主调度算法 (`generateSchedule`)

```
算法 generateSchedule()
输入: 实验室列表 Labs, 申请列表 Requests
输出: 成功分配的申请数量

1. 清空旧的课程安排数据
2. 初始化实验室占用情况表 labOccupancy
3. 从数据库获取所有实验室和申请
4. 验证数据完整性(实验室和申请均不为空)
5. 对申请列表按优先级升序排序  // 已在数据库查询时完成
6. FOR EACH 申请 request IN Requests DO
7.     IF allocateRequest(request, Labs) THEN
8.         successCount++
9.     END IF
10. END FOR
11. 输出统计信息(成功数、失败数、成功率)
12. RETURN successCount
```

#### 申请分配算法 (`allocateRequest`)

这是算法的核心部分,采用**两阶段贪心策略**:

```
算法 allocateRequest(request, Labs)
输入: 单个申请 request, 实验室列表 Labs
输出: 是否成功分配 (true/false)

// ========== 第一阶段: 优先满足期望时间段 ==========
1. FOR EACH 时间槽 slot IN request.preferredSlots DO
2.     IF slot IN request.excludedSlots THEN
3.         CONTINUE  // 跳过排除的时间段
4.     END IF
5.     
6.     FOR EACH 实验室 lab IN Labs DO
7.         IF lab.capacity < request.studentCount THEN
8.             CONTINUE  // 容量不足,跳过
9.         END IF
10.        
11.        IF NOT isLabAvailable(lab.id, slot) THEN
12.            CONTINUE  // 该时段已被占用,跳过
13.        END IF
14.        
15.        // 找到合适的匹配,进行分配
16.        创建 Schedule(request.id, lab.id, slot)
17.        保存到数据库
18.        markLabOccupied(lab.id, slot)
19.        输出分配成功日志
20.        RETURN true
21.    END FOR
22. END FOR

// ========== 第二阶段: 尝试其他可用时间段 ==========
23. 生成所有可能的时间槽 allSlots  // 2周 × 5天 × 2时段 = 20个时间槽
24. FOR EACH 时间槽 slot IN allSlots DO
25.     IF slot IN request.excludedSlots THEN
26.         CONTINUE  // 跳过排除的时间段
27.     END IF
28.     
29.     IF slot IN request.preferredSlots THEN
30.         CONTINUE  // 已在第一阶段尝试过,跳过
31.     END IF
32.     
33.     FOR EACH 实验室 lab IN Labs DO
34.         IF lab.capacity < request.studentCount THEN
35.             CONTINUE
36.         END IF
37.         
38.         IF NOT isLabAvailable(lab.id, slot) THEN
39.             CONTINUE
40.         END IF
41.         
42.         // 找到可用的实验室和时间段
43.         创建 Schedule(request.id, lab.id, slot)
44.         保存到数据库
45.         markLabOccupied(lab.id, slot)
46.         输出备选分配日志
47.         RETURN true
48.     END FOR
49. END FOR

50. 输出分配失败日志
51. RETURN false  // 无法为该申请找到合适的分配
```

### 辅助算法

#### 实验室可用性检查 (`isLabAvailable`)

```
算法 isLabAvailable(labId, slot)
输入: 实验室ID, 时间槽
输出: 是否可用 (true/false)

1. IF labId NOT IN labOccupancy THEN
2.     RETURN true  // 该实验室尚未被占用
3. END IF
4. RETURN slot NOT IN labOccupancy[labId]
```

时间复杂度: O(log n),其中n为该实验室已占用的时间槽数量(使用STL set)

#### 标记实验室占用 (`markLabOccupied`)

```
算法 markLabOccupied(labId, slot)
输入: 实验室ID, 时间槽
输出: 无

1. 将 slot 添加到 labOccupancy[labId]
```

时间复杂度: O(log n)

### 算法复杂度分析

设:
- R = 申请数量
- L = 实验室数量
- P = 期望时间槽数量(平均每个申请)
- T = 总可用时间槽数量(固定为20: 2周×5天×2时段)

#### 时间复杂度

1. **最好情况**: O(R × P × L)
   - 所有申请都在第一阶段(期望时间段)成功分配
   - 每个申请遍历P个期望时间槽,每个时间槽遍历L个实验室

2. **最坏情况**: O(R × T × L)
   - 所有申请都需要进入第二阶段
   - 每个申请遍历所有T个时间槽,每个时间槽遍历L个实验室

3. **平均情况**: O(R × (P + T/2) × L)
   - 部分申请在第一阶段成功,部分进入第二阶段

#### 空间复杂度

O(L × S),其中S为平均每个实验室占用的时间槽数量
- 使用map存储实验室占用情况
- 每个实验室用set存储占用的时间槽

### 算法特点与优化

#### 优点

1. **贪心策略高效**: 按优先级顺序一次遍历,避免回溯
2. **公平性保证**: 严格按照申请顺序(优先级)分配
3. **两阶段匹配**: 优先满足期望,无法满足时自动降级
4. **冲突避免**: 使用哈希表快速检查时间冲突
5. **容量约束**: 确保实验室容量安全

#### 可能的改进方向

1. **回溯优化**: 当前算法不支持回溯,可能出现局部最优。可以考虑:
   - 引入A*搜索或分支限界法
   - 实现基于优先级队列的动态调整

2. **负载均衡**: 在多个实验室可选时,优先选择使用率较低的实验室

3. **时间段权重**: 为不同时间段设置权重(如上午>下午)

### 算法正确性证明

#### 定理: 算法满足所有硬约束

**证明:**

1. **容量约束**: 
   - 第7-9行和第34-36行确保 `lab.capacity ≥ request.studentCount`
   - 只有满足容量要求的实验室才会被分配

2. **时间冲突避免**:
   - `isLabAvailable` 检查确保同一实验室同一时间只分配一次
   - `markLabOccupied` 标记已占用时间,防止后续重复分配

3. **排除时间段**:
   - 第2-4行和第25-27行过滤掉所有排除的时间段
   - 确保不会分配到教师不可用的时间

4. **优先级保证**:
   - 申请按优先级排序后顺序处理
   - 先处理的申请优先选择资源

**结论**: 算法生成的所有课程安排都满足硬约束条件,不会出现冲突或违规。

---

## 数据库设计

### 表结构设计

#### 1. laboratories (实验室表)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | INTEGER PRIMARY KEY | 实验室ID(自增) |
| location | TEXT NOT NULL | 实验室地址 |
| capacity | INTEGER NOT NULL | 容纳人数 |

#### 2. requests (申请表)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | INTEGER PRIMARY KEY | 申请ID(自增) |
| class_id | TEXT NOT NULL | 班级ID |
| student_count | INTEGER NOT NULL | 学生人数 |
| teacher | TEXT NOT NULL | 指导教师 |
| preferred_slots | TEXT NOT NULL | 期望时间段(序列化) |
| excluded_slots | TEXT NOT NULL | 排除时间段(序列化) |
| priority | INTEGER NOT NULL | 优先级 |

#### 3. schedules (课程安排表)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | INTEGER PRIMARY KEY | 安排ID(自增) |
| request_id | INTEGER NOT NULL | 关联申请ID |
| lab_id | INTEGER NOT NULL | 关联实验室ID |
| week | INTEGER NOT NULL | 周次(9或10) |
| day | INTEGER NOT NULL | 星期(0-4) |
| period | INTEGER NOT NULL | 时段(0-上午, 1-下午) |

### 时间槽序列化格式

时间槽数据以字符串形式存储,格式为: `week,day,period;week,day,period;...`

示例: `9,0,0;9,1,0;9,2,0` 表示第9周周一上午、周二上午、周三上午

---

## 项目结构

```
algo-homework/
├── CMakeLists.txt          # CMake构建配置
├── src/
│   ├── main.cpp            # 程序入口
│   ├── widget.h/cpp        # 主界面(UI集成)
│   ├── database.h/cpp      # 数据库管理模块
│   └── scheduler.h/cpp     # 调度算法模块
├── third_party/
│   └── sqlite/             # SQLite库
└── build/                  # 构建输出目录
```

### 模块说明

#### 1. Database模块 (`database.h/cpp`)
- 封装SQLite数据库操作
- 提供实验室、申请、课程安排的CRUD接口
- 实现时间槽的序列化/反序列化
- 支持按实验室和班级查询课程安排

#### 2. Scheduler模块 (`scheduler.h/cpp`)
- 实现核心调度算法
- 管理实验室占用情况
- 提供调度统计功能
- 输出详细的分配日志

#### 3. Widget模块 (`widget.h/cpp`)
- 实现Qt图形用户界面
- 四个功能标签页:
  1. 实验室管理
  2. 申请管理
  3. 课表生成
  4. 课表查询
- 整合数据库和调度器

---

## 使用说明

### 编译与运行

1. **安装依赖**:
   - Qt 6.5或更高版本
   - CMake 3.19或更高版本
   - MSVC 2022或其他C++编译器

2. **构建项目**:
   ```bash
   mkdir build
   cd build
   cmake ..
   cmake --build .
   ```

3. **运行程序**:
   ```bash
   ./algo-homework.exe  # Windows
   ./algo-homework      # Linux/Mac
   ```

### 操作流程

#### 步骤1: 添加实验室
1. 打开"实验室管理"标签页
2. 输入实验室地址(如: 实验楼A301)
3. 设置容纳人数(如: 40)
4. 点击"添加实验室"按钮

#### 步骤2: 添加申请
1. 打开"申请管理"标签页
2. 填写基本信息:
   - 班级ID: B210307
   - 学生人数: 33
   - 指导教师: 朱洁
   - 优先级: 1(数字越小优先级越高)
3. 选择时间段:
   - **左键点击**: 设置为期望时间段(蓝色)
   - **右键点击**: 设置为不可用时间段(红色)
   - **再次点击**: 取消选择
4. 点击"添加申请"按钮

#### 步骤3: 生成课表
1. 打开"课表生成"标签页
2. 点击"生成课程安排"按钮
3. 查看调度结果统计信息

#### 步骤4: 查询课表
1. 打开"课表查询"标签页
2. 选择查询方式:
   - **按实验室查询**: 从下拉框选择实验室,点击"查询"
   - **按班级查询**: 输入班级ID,点击"查询"
3. 查看课程安排结果表格

---

## 示例数据

### 实验室数据示例

| 实验室地址 | 容纳人数 |
|-----------|---------|
| 实验楼A301 | 40 |
| 实验楼A302 | 40 |
| 实验楼B201 | 50 |

### 申请数据示例(参考题目表格)

| 班级 | 人数 | 教师 | 优先级 | 期望时间段 |
|------|------|------|--------|-----------|
| B210307 | 33 | 朱洁 | 1 | 第9周周一至周五上午 |
| B210308 | 36 | 胡惠娟 | 2 | 第9周周一、周二上午 |
| B210309 | 33 | 戴华 | 3 | 第9周周二、周三上午 |

### 生成的课表示例

| 班级 | 教师 | 实验室 | 周次 | 星期 | 时段 |
|------|------|--------|------|------|------|
| B210307 | 朱洁 | 实验楼A301 | 第9周 | 周一 | 上午 |
| B210308 | 胡惠娟 | 实验楼A302 | 第9周 | 周一 | 上午 |
| B210309 | 戴华 | 实验楼A301 | 第9周 | 周二 | 上午 |

---

## 实现亮点

### 1. 算法创新
- **两阶段贪心策略**: 优先满足期望,兜底保证可用性
- **优先级调度**: 公平性与效率的平衡
- **快速冲突检测**: 使用STL map和set,O(log n)复杂度

### 2. 用户体验
- **可视化时间选择**: 三态复选框(期望/排除/未选)
- **实时反馈**: 每次操作都有明确的提示信息
- **统计信息**: 详细的调度成功率和失败列表

### 3. 工程质量
- **模块化设计**: 数据库、算法、UI完全解耦
- **异常处理**: 完善的错误检查和用户提示
- **代码注释**: 详细的算法步骤说明
- **数据持久化**: 使用SQLite保证数据安全

### 4. 可扩展性
- 易于增加新的时间段(如增加周末)
- 易于修改调度策略(如负载均衡)
- 易于添加新的约束条件(如教师偏好权重)

---

## 提高要求实现

### ✅ 已实现
1. **先进而高效的算法**: 
   - 两阶段贪心匹配
   - 优先级调度
   - 快速冲突检测
   
2. **界面美观,课表整齐**: 
   - 使用Qt现代化UI
   - 表格清晰展示课表
   - 分标签页组织功能

### 🚀 可扩展实现
1. **批量导入功能**: 可添加CSV/Excel导入模块
2. **高级优化算法**: 可引入整数规划、遗传算法等

---

## 测试建议

### 测试用例1: 基本功能测试
- 添加3个实验室(容量: 35, 40, 50)
- 添加5个申请(人数: 30-40)
- 生成课表,验证无冲突

### 测试用例2: 容量约束测试
- 添加1个小实验室(容量: 20)
- 添加1个大班级申请(人数: 50)
- 验证无法分配

### 测试用例3: 优先级测试
- 添加多个申请,优先级不同
- 验证低优先级申请在高优先级之后处理

### 测试用例4: 时间冲突测试
- 多个班级申请同一时间段
- 验证同一实验室同一时间只分配一次

---

## 总结

本实验室安排系统成功实现了实验室资源的自动化调度,核心算法采用**基于优先级的两阶段贪心策略**,在保证公平性的前提下最大化资源利用率。系统具有良好的用户界面、完善的数据管理和详细的调度统计,满足题目的所有基本要求和部分提高要求。

算法的时间复杂度为O(R×T×L),在实际应用场景中表现优秀。通过模块化设计,系统具有良好的可扩展性,易于后续功能增强和算法优化。

---

## 作者信息

- **项目名称**: 实验室安排系统
- **课程**: 算法与数据结构设计
- **开发时间**: 2025年12月
- **技术栈**: C++, Qt6, SQLite, CMake

